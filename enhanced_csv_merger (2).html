<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced CSV Location Data Merger</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            transition: all 0.3s ease;
        }
        
        .upload-box:hover {
            border-color: #764ba2;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
            transform: translateY(-2px);
        }
        
        .upload-box h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .file-input {
            margin: 10px 0;
            padding: 10px 20px;
            border: none;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .file-input:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .settings-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }
        
        .settings-section h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
        }
        
        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .button-group {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 15px 30px;
            border: none;
            border-radius: 30px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            text-decoration: none;
            display: inline-block;
            text-align: center;
        }
        
        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        
        .btn-secondary {
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
        }
        
        .btn-warning {
            background: linear-gradient(45deg, #ffc107, #ff8c00);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 25px rgba(0,0,0,0.2);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            background: #cccccc;
        }
        
        .results {
            margin-top: 30px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 12px;
            border-left: 5px solid #667eea;
        }
        
        .results h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .status.success {
            background: rgba(40, 167, 69, 0.1);
            color: #155724;
            border: 1px solid rgba(40, 167, 69, 0.2);
        }
        
        .status.error {
            background: rgba(220, 53, 69, 0.1);
            color: #721c24;
            border: 1px solid rgba(220, 53, 69, 0.2);
        }
        
        .status.info {
            background: rgba(23, 162, 184, 0.1);
            color: #0c5460;
            border: 1px solid rgba(23, 162, 184, 0.2);
        }
        
        .status.warning {
            background: rgba(255, 193, 7, 0.1);
            color: #856404;
            border: 1px solid rgba(255, 193, 7, 0.2);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        th, td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
            font-size: 13px;
        }
        
        th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
            position: sticky;
            top: 0;
        }
        
        tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }
        
        .preview-container {
            max-height: 500px;
            overflow: auto;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .confidence-high { background-color: rgba(40, 167, 69, 0.1); }
        .confidence-medium { background-color: rgba(255, 193, 7, 0.1); }
        .confidence-low { background-color: rgba(220, 53, 69, 0.1); }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .edit-row {
            background: rgba(255, 255, 255, 0.95);
        }

        .edit-select {
            width: 100%;
            padding: 4px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 12px;
        }

        .tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            background: transparent;
            border: none;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .tab.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Enhanced CSV Location Data Merger</h1>
        <p style="text-align: center; color: #666; margin-bottom: 30px;">Verified location matching with preview and editing capabilities</p>
        
        <div class="upload-section">
            <div class="upload-box">
                <h3>üìç Cities CSV File</h3>
                <p>Upload your cities data with location information</p>
                <input type="file" id="citiesFile" accept=".csv" class="file-input">
                <div id="citiesStatus"></div>
            </div>
            
            <div class="upload-box">
                <h3>üë• Bio Data CSV File</h3>
                <p>Upload your bio/influencer data</p>
                <input type="file" id="bioFile" accept=".csv" class="file-input">
                <div id="bioStatus"></div>
            </div>
        </div>
        
        <div class="settings-section">
            <h3>üîß Matching Settings</h3>
            <div class="checkbox-group">
                <div class="checkbox-item">
                    <input type="checkbox" id="strictMode" checked>
                    <label for="strictMode">Strict matching (higher accuracy)</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="requireStateMatch" checked>
                    <label for="requireStateMatch">Require state verification</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="validateAbbreviations" checked>
                    <label for="validateAbbreviations">Validate abbreviations</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="contextualMatching" checked>
                    <label for="contextualMatching">Use contextual keywords</label>
                </div>
            </div>
        </div>
        
        <div class="button-group">
            <button id="previewBtn" class="btn btn-warning" disabled>üëÅÔ∏è Preview Matches</button>
            <button id="mergeBtn" class="btn btn-primary" disabled>üîÑ Process All Data</button>
            <button id="downloadBtn" class="btn btn-secondary" style="display: none;">üíæ Download Results</button>
        </div>
        
        <div id="results" class="results" style="display: none;">
            <div class="tabs">
                <button class="tab active" onclick="switchTab('preview')">üìä Preview Results</button>
                <button class="tab" onclick="switchTab('edit')">‚úèÔ∏è Edit Matches</button>
                <button class="tab" onclick="switchTab('stats')">üìà Statistics</button>
            </div>

            <div id="preview-tab" class="tab-content active">
                <h3>üìä Processing Results</h3>
                <div id="mergeStatus"></div>
                <div id="previewContainer"></div>
            </div>

            <div id="edit-tab" class="tab-content">
                <h3>‚úèÔ∏è Edit and Verify Matches</h3>
                <div id="editContainer"></div>
            </div>

            <div id="stats-tab" class="tab-content">
                <h3>üìà Detailed Statistics</h3>
                <div id="statsContainer"></div>
            </div>
        </div>
    </div>

    <script>
        let citiesData = null;
        let bioData = null;
        let processedData = null;
        let cityIndex = new Map();
        let stateIndex = new Map();

        // US States data
        const US_STATES = {
            'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas', 'CA': 'California', 'CO': 'Colorado',
            'CT': 'Connecticut', 'DE': 'Delaware', 'FL': 'Florida', 'GA': 'Georgia', 'HI': 'Hawaii', 'ID': 'Idaho',
            'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa', 'KS': 'Kansas', 'KY': 'Kentucky', 'LA': 'Louisiana',
            'ME': 'Maine', 'MD': 'Maryland', 'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi',
            'MO': 'Missouri', 'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada', 'NH': 'New Hampshire', 'NJ': 'New Jersey',
            'NM': 'New Mexico', 'NY': 'New York', 'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio', 'OK': 'Oklahoma',
            'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina', 'SD': 'South Dakota',
            'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah', 'VT': 'Vermont', 'VA': 'Virginia', 'WA': 'Washington',
            'WV': 'West Virginia', 'WI': 'Wisconsin', 'WY': 'Wyoming'
        };

        const LOCATION_KEYWORDS = [
            'from', 'in', 'at', 'based', 'located', 'live', 'lives', 'resident', 'living',
            'born', 'raised', 'hometown', 'home', 'city', 'state', 'area', 'place',
            'üìç', 'üìå', 'üó∫Ô∏è', 'üèôÔ∏è', 'üè†', 'üåÜ'
        ];

        // Event listeners - Fixed to ensure proper binding
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, setting up event listeners');
            
            document.getElementById('citiesFile').addEventListener('change', function(e) {
                console.log('Cities file selected:', e.target.files[0]?.name);
                const file = e.target.files[0];
                if (file) parseCSV(file, 'cities');
            });

            document.getElementById('bioFile').addEventListener('change', function(e) {
                console.log('Bio file selected:', e.target.files[0]?.name);
                const file = e.target.files[0];
                if (file) parseCSV(file, 'bio');
            });

            document.getElementById('previewBtn').addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Preview button clicked');
                if (!this.disabled) {
                    previewMatches();
                } else {
                    console.log('Preview button is disabled');
                }
            });

            document.getElementById('mergeBtn').addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Merge button clicked');
                if (!this.disabled) {
                    processAllData();
                } else {
                    console.log('Merge button is disabled');
                }
            });

            document.getElementById('downloadBtn').addEventListener('click', function(e) {
                e.preventDefault();
                console.log('Download button clicked');
                downloadResults();
            });
            
            // Initial button state
            updateButtonStates();
        });

        // Fallback event listeners (in case DOMContentLoaded already fired)
        document.getElementById('citiesFile')?.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) parseCSV(file, 'cities');
        });

        document.getElementById('bioFile')?.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) parseCSV(file, 'bio');
        });

        document.getElementById('previewBtn')?.addEventListener('click', function(e) {
            e.preventDefault();
            if (!this.disabled) previewMatches();
        });

        document.getElementById('mergeBtn')?.addEventListener('click', function(e) {
            e.preventDefault();
            if (!this.disabled) processAllData();
        });

        document.getElementById('downloadBtn')?.addEventListener('click', downloadResults);

        function parseCSV(file, type) {
            const statusDiv = document.getElementById(type + 'Status');
            statusDiv.innerHTML = '<div class="status info">üìÅ Parsing CSV file...</div>';

            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: false,
                complete: function(results) {
                    console.log(`Parsing completed for ${type}:`, results.data.length, 'rows');
                    
                    if (results.errors.length > 0) {
                        console.error('Parse errors:', results.errors);
                        statusDiv.innerHTML = `<div class="status error">‚ùå Error: ${results.errors[0].message}</div>`;
                        return;
                    }

                    if (type === 'cities') {
                        const originalCount = results.data.length;
                        citiesData = results.data.filter(row => row && (row.city || row.city_ascii));
                        console.log(`Cities filtered: ${originalCount} -> ${citiesData.length}`);
                        buildLocationIndexes();
                        statusDiv.innerHTML = `
                            <div class="status success">
                                ‚úÖ Cities CSV loaded<br>
                                üìä Total rows: <strong>${originalCount}</strong><br>
                                üèôÔ∏è Valid cities: <strong>${citiesData.length}</strong><br>
                                üóÇÔ∏è Columns: <strong>${Object.keys(results.data[0] || {}).length}</strong>
                            </div>`;
                    } else {
                        const originalCount = results.data.length;
                        bioData = results.data.filter(row => row && Object.values(row).some(val => val && val.toString().trim()));
                        console.log(`Bio data filtered: ${originalCount} -> ${bioData.length}`);
                        statusDiv.innerHTML = `
                            <div class="status success">
                                ‚úÖ Bio CSV loaded<br>
                                üìä Total rows: <strong>${originalCount}</strong><br>
                                üë• Valid records: <strong>${bioData.length}</strong><br>
                                üóÇÔ∏è Columns: <strong>${Object.keys(results.data[0] || {}).length}</strong>
                            </div>`;
                    }

                    // Force button state update
                    setTimeout(updateButtonStates, 100);
                },
                error: function(error) {
                    console.error('Parse error:', error);
                    statusDiv.innerHTML = `<div class="status error">‚ùå Error: ${error.message}</div>`;
                }
            });
        }

        function buildLocationIndexes() {
            cityIndex.clear();
            stateIndex.clear();

            citiesData.forEach(city => {
                if (!city) return;

                // Build city index
                if (city.city) {
                    const key = city.city.toLowerCase().trim();
                    if (!cityIndex.has(key)) cityIndex.set(key, []);
                    cityIndex.get(key).push(city);
                }

                if (city.city_ascii && city.city_ascii !== city.city) {
                    const key = city.city_ascii.toLowerCase().trim();
                    if (!cityIndex.has(key)) cityIndex.set(key, []);
                    cityIndex.get(key).push(city);
                }

                // Build state index
                if (city.state_name) {
                    const key = city.state_name.toLowerCase().trim();
                    if (!stateIndex.has(key)) stateIndex.set(key, []);
                    stateIndex.get(key).push(city);
                }

                if (city.state_id) {
                    const key = city.state_id.toLowerCase().trim();
                    if (!stateIndex.has(key)) stateIndex.set(key, []);
                    stateIndex.get(key).push(city);
                }
            });

            console.log(`Indexes built: ${cityIndex.size} cities, ${stateIndex.size} states`);
        }

        function updateButtonStates() {
            const previewBtn = document.getElementById('previewBtn');
            const mergeBtn = document.getElementById('mergeBtn');
            
            console.log('Updating button states:', {
                citiesData: citiesData ? citiesData.length : 'null',
                bioData: bioData ? bioData.length : 'null'
            });
            
            const ready = citiesData && bioData && citiesData.length > 0 && bioData.length > 0;
            
            if (ready) {
                previewBtn.disabled = false;
                mergeBtn.disabled = false;
                previewBtn.textContent = `üëÅÔ∏è Preview Matches (${bioData.length} records)`;
                mergeBtn.textContent = `üîÑ Process All Data (${bioData.length} records)`;
                previewBtn.style.opacity = '1';
                mergeBtn.style.opacity = '1';
                previewBtn.style.cursor = 'pointer';
                mergeBtn.style.cursor = 'pointer';
                
                console.log('Buttons enabled successfully');
            } else {
                previewBtn.disabled = true;
                mergeBtn.disabled = true;
                previewBtn.textContent = 'üëÅÔ∏è Preview Matches';
                mergeBtn.textContent = 'üîÑ Process All Data';
                previewBtn.style.opacity = '0.6';
                mergeBtn.style.opacity = '0.6';
                previewBtn.style.cursor = 'not-allowed';
                mergeBtn.style.cursor = 'not-allowed';
                
                console.log('Buttons disabled - waiting for data');
            }
        }

        function findLocationInText(text) {
            if (!text || typeof text !== 'string') return null;
            
            const textLower = text.toLowerCase();
            let bestMatch = null;
            let highestScore = 0;

            // Extract potential location words
            const words = textLower.split(/[\s,;.:!?\-_\(\)\[\]{}|\/\\'"]+/)
                .filter(word => word && word.length > 1);

            // Check for city matches first (highest priority)
            for (const word of words) {
                if (cityIndex.has(word)) {
                    const cities = cityIndex.get(word);
                    for (const city of cities) {
                        let score = 100 + (city.population || 0) / 10000; // Base score + population bonus
                        
                        // Context bonus
                        if (hasLocationContext(text, word)) score += 20;
                        
                        // State verification bonus
                        if (document.getElementById('requireStateMatch').checked) {
                            if (verifyStateInText(text, city)) {
                                score += 30;
                            } else {
                                score -= 20;
                            }
                        }

                        if (score > highestScore) {
                            highestScore = score;
                            bestMatch = {
                                city: city,
                                matchType: 'city',
                                matchedText: word,
                                confidence: score > 120 ? 'high' : score > 80 ? 'medium' : 'low',
                                score: score
                            };
                        }
                    }
                }
            }

            // If no city match and not in strict mode, try state matches
            if (!bestMatch && !document.getElementById('strictMode').checked) {
                for (const word of words) {
                    if (stateIndex.has(word)) {
                        const cities = stateIndex.get(word);
                        const largestCity = cities.reduce((prev, curr) => 
                            (curr.population || 0) > (prev.population || 0) ? curr : prev
                        );

                        const score = 60 + (largestCity.population || 0) / 20000;
                        if (score > highestScore) {
                            highestScore = score;
                            bestMatch = {
                                city: largestCity,
                                matchType: 'state',
                                matchedText: word,
                                confidence: 'medium',
                                score: score
                            };
                        }
                    }

                    // Check state abbreviations
                    if (document.getElementById('validateAbbreviations').checked) {
                        const upperWord = word.toUpperCase();
                        if (US_STATES[upperWord]) {
                            const stateName = US_STATES[upperWord].toLowerCase();
                            if (stateIndex.has(stateName)) {
                                const cities = stateIndex.get(stateName);
                                const largestCity = cities.reduce((prev, curr) => 
                                    (curr.population || 0) > (prev.population || 0) ? curr : prev
                                );

                                const score = 80 + (largestCity.population || 0) / 20000;
                                if (score > highestScore) {
                                    highestScore = score;
                                    bestMatch = {
                                        city: largestCity,
                                        matchType: 'abbreviation',
                                        matchedText: word,
                                        confidence: 'high',
                                        score: score
                                    };
                                }
                            }
                        }
                    }
                }
            }

            return bestMatch;
        }

        function hasLocationContext(text, word) {
            const textLower = text.toLowerCase();
            const wordIndex = textLower.indexOf(word);
            if (wordIndex === -1) return false;

            const contextStart = Math.max(0, wordIndex - 20);
            const contextEnd = Math.min(textLower.length, wordIndex + word.length + 20);
            const context = textLower.substring(contextStart, contextEnd);

            return LOCATION_KEYWORDS.some(keyword => context.includes(keyword));
        }

        function verifyStateInText(text, city) {
            if (!city.state_name && !city.state_id) return false;
            
            const textLower = text.toLowerCase();
            return (city.state_name && textLower.includes(city.state_name.toLowerCase())) ||
                   (city.state_id && textLower.includes(city.state_id.toLowerCase()));
        }

        function previewMatches() {
            console.log('Starting preview matches...');
            
            if (!bioData || bioData.length === 0) {
                alert('Please upload bio data first!');
                return;
            }
            
            if (!citiesData || citiesData.length === 0) {
                alert('Please upload cities data first!');
                return;
            }
            
            const statusDiv = document.getElementById('mergeStatus');
            statusDiv.innerHTML = '<div class="status info">üîç Analyzing first 10 records for preview...</div>';

            const previewData = bioData.slice(0, 10);
            const results = [];

            console.log('Processing preview data:', previewData.length, 'records');

            previewData.forEach((record, index) => {
                console.log(`Processing record ${index + 1}:`, Object.keys(record));
                
                const result = { ...record, originalIndex: index };
                
                // Search for location in all text fields
                let bestMatch = null;
                let searchedIn = '';

                for (const [key, value] of Object.entries(record)) {
                    if (value && typeof value === 'string' && value.trim()) {
                        const match = findLocationInText(value);
                        if (match && (!bestMatch || match.score > bestMatch.score)) {
                            bestMatch = match;
                            searchedIn = key;
                        }
                    }
                }

                if (bestMatch) {
                    result.location_match = 'YES';
                    result.found_city = bestMatch.city.city || '';
                    result.found_state = bestMatch.city.state_name || '';
                    result.match_confidence = bestMatch.confidence;
                    result.matched_in = searchedIn;
                    result.matched_text = bestMatch.matchedText;
                    console.log(`Match found for record ${index + 1}:`, bestMatch.city.city, bestMatch.city.state_name);
                } else {
                    result.location_match = 'NO';
                    result.found_city = '';
                    result.found_state = '';
                    result.match_confidence = 'none';
                    result.matched_in = '';
                    result.matched_text = '';
                    console.log(`No match found for record ${index + 1}`);
                }

                results.push(result);
            });

            console.log('Preview results:', results);
            displayPreviewResults(results);
            document.getElementById('results').style.display = 'block';
        }

        function processAllData() {
            const statusDiv = document.getElementById('mergeStatus');
            statusDiv.innerHTML = '<div class="status info">üîÑ Processing all records...</div>';

            processedData = [];
            let totalMatches = 0;

            bioData.forEach((record, index) => {
                const result = { ...record };
                
                // Search for location in all text fields
                let bestMatch = null;
                let searchedIn = '';

                for (const [key, value] of Object.entries(record)) {
                    if (value && typeof value === 'string' && value.trim()) {
                        const match = findLocationInText(value);
                        if (match && (!bestMatch || match.score > bestMatch.score)) {
                            bestMatch = match;
                            searchedIn = key;
                        }
                    }
                }

                if (bestMatch) {
                    // Add all city data columns
                    Object.keys(citiesData[0] || {}).forEach(col => {
                        result[col] = bestMatch.city[col] || '';
                    });
                    
                    result.location_match = 'YES';
                    result.match_confidence = bestMatch.confidence;
                    result.matched_in_column = searchedIn;
                    result.matched_text_fragment = bestMatch.matchedText;
                    result.match_type = bestMatch.matchType;
                    totalMatches++;
                } else {
                    // Add empty location columns
                    Object.keys(citiesData[0] || {}).forEach(col => {
                        result[col] = '';
                    });
                    
                    result.location_match = 'NO';
                    result.match_confidence = 'none';
                    result.matched_in_column = '';
                    result.matched_text_fragment = '';
                    result.match_type = 'none';
                }

                processedData.push(result);
            });

            displayAllResults(processedData, totalMatches);
            document.getElementById('downloadBtn').style.display = 'inline-block';
        }

        function displayPreviewResults(results) {
            const container = document.getElementById('previewContainer');
            const matchCount = results.filter(r => r.location_match === 'YES').length;
            
            let html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number">${results.length}</div>
                        <div class="stat-label">Records Previewed</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${matchCount}</div>
                        <div class="stat-label">Matches Found</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${Math.round(matchCount/results.length*100)}%</div>
                        <div class="stat-label">Success Rate</div>
                    </div>
                </div>
                
                <div class="preview-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Match</th>
                                <th>City Found</th>
                                <th>State</th>
                                <th>Confidence</th>
                                <th>Matched In</th>
                                <th>Text Fragment</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            results.forEach(result => {
                const rowClass = `confidence-${result.match_confidence}`;
                html += `
                    <tr class="${rowClass}">
                        <td>${result.location_match}</td>
                        <td>${result.found_city}</td>
                        <td>${result.found_state}</td>
                        <td>${result.match_confidence}</td>
                        <td>${result.matched_in}</td>
                        <td>${result.matched_text ? result.matched_text.substring(0, 30) + '...' : ''}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            container.innerHTML = html;
            
            document.getElementById('mergeStatus').innerHTML = `
                <div class="status success">‚úÖ Preview completed! Found ${matchCount} matches out of ${results.length} records (${Math.round(matchCount/results.length*100)}% success rate)</div>
            `;
        }

        function displayAllResults(results, totalMatches) {
            const container = document.getElementById('previewContainer');
            const successRate = Math.round(totalMatches/results.length*100);
            
            // Count confidence levels
            const highConf = results.filter(r => r.match_confidence === 'high').length;
            const medConf = results.filter(r => r.match_confidence === 'medium').length;
            const lowConf = results.filter(r => r.match_confidence === 'low').length;
            
            let html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number">${results.length}</div>
                        <div class="stat-label">Total Records</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${totalMatches}</div>
                        <div class="stat-label">Matches Found</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${successRate}%</div>
                        <div class="stat-label">Success Rate</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${highConf}</div>
                        <div class="stat-label">High Confidence</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${medConf}</div>
                        <div class="stat-label">Medium Confidence</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${lowConf}</div>
                        <div class="stat-label">Low Confidence</div>
                    </div>
                </div>
                
                <div class="preview-container">
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Match Status</th>
                                <th>City Found</th>
                                <th>State Found</th>
                                <th>Confidence</th>
                                <th>Match Type</th>
                                <th>Found In Column</th>
                                <th>Matched Text</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            results.slice(0, 50).forEach((result, index) => {
                const rowClass = `confidence-${result.match_confidence}`;
                html += `
                    <tr class="${rowClass}">
                        <td>${index + 1}</td>
                        <td>${result.location_match}</td>
                        <td>${result.city || ''}</td>
                        <td>${result.state_name || ''}</td>
                        <td>${result.match_confidence}</td>
                        <td>${result.match_type}</td>
                        <td>${result.matched_in_column}</td>
                        <td>${result.matched_text_fragment ? result.matched_text_fragment.substring(0, 25) + '...' : ''}</td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
                <p style="text-align: center; color: #666; margin-top: 15px;">
                    Showing first 50 records of ${results.length} total processed records
                </p>
            `;

            container.innerHTML = html;
            
            // Update edit tab
            displayEditInterface(results);
            
            // Update stats tab
            displayDetailedStats(results, totalMatches);
            
            document.getElementById('mergeStatus').innerHTML = `
                <div class="status success">
                    ‚úÖ Processing completed! Successfully matched ${totalMatches} out of ${results.length} records (${successRate}% success rate)
                </div>
            `;
        }

        function displayEditInterface(results) {
            const container = document.getElementById('editContainer');
            const matchedRecords = results.filter(r => r.location_match === 'YES').slice(0, 20);
            
            if (matchedRecords.length === 0) {
                container.innerHTML = '<div class="status info">No matches found to edit.</div>';
                return;
            }

            let html = `
                <div class="status info">
                    <p>üìù Review and edit location matches. Changes are applied when you download the results.</p>
                    <p>Showing first 20 matched records for editing:</p>
                </div>
                
                <div class="preview-container">
                    <table>
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Original Data</th>
                                <th>Current City</th>
                                <th>Current State</th>
                                <th>Confidence</th>
                                <th>Edit City</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            matchedRecords.forEach((result, index) => {
                const originalData = Object.entries(result)
                    .filter(([key, value]) => !key.startsWith('city') && !key.startsWith('state') && !key.startsWith('location_') && !key.startsWith('match') && value)
                    .slice(0, 2)
                    .map(([key, value]) => `${key}: ${String(value).substring(0, 30)}...`)
                    .join('<br>');

                html += `
                    <tr class="edit-row confidence-${result.match_confidence}" data-index="${index}">
                        <td>${index + 1}</td>
                        <td style="font-size: 11px;">${originalData}</td>
                        <td>${result.city || 'N/A'}</td>
                        <td>${result.state_name || 'N/A'}</td>
                        <td>
                            <span class="badge ${result.match_confidence}">${result.match_confidence}</span>
                        </td>
                        <td>
                            <select class="edit-select" onchange="updateMatch(${index}, this.value)">
                                <option value="">-- Change City --</option>
                            </select>
                        </td>
                        <td>
                            <button onclick="removeMatch(${index})" style="background: #dc3545; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer;">
                                Remove
                            </button>
                        </td>
                    </tr>
                `;
            });

            html += `
                        </tbody>
                    </table>
                </div>
            `;

            container.innerHTML = html;
            
            // Populate city dropdowns
            populateCityDropdowns();
        }

        function populateCityDropdowns() {
            const selects = document.querySelectorAll('.edit-select');
            const cityOptions = [];
            
            // Get unique cities with state info
            const uniqueCities = new Map();
            citiesData.forEach(city => {
                if (city.city && city.state_name) {
                    const key = `${city.city}, ${city.state_name}`;
                    if (!uniqueCities.has(key)) {
                        uniqueCities.set(key, city);
                    }
                }
            });
            
            // Sort by population (largest first) and take top 200
            const topCities = Array.from(uniqueCities.values())
                .sort((a, b) => (b.population || 0) - (a.population || 0))
                .slice(0, 200);
            
            selects.forEach(select => {
                topCities.forEach(city => {
                    const option = document.createElement('option');
                    option.value = JSON.stringify(city);
                    option.textContent = `${city.city}, ${city.state_name} (${city.population || 'N/A'})`;
                    select.appendChild(option);
                });
            });
        }

        function displayDetailedStats(results, totalMatches) {
            const container = document.getElementById('statsContainer');
            
            // Calculate various statistics
            const matchTypes = {};
            const confidenceLevels = {};
            const columnSources = {};
            const stateDistribution = {};
            
            results.forEach(result => {
                if (result.location_match === 'YES') {
                    // Match types
                    const matchType = result.match_type || 'unknown';
                    matchTypes[matchType] = (matchTypes[matchType] || 0) + 1;
                    
                    // Confidence levels
                    const confidence = result.match_confidence || 'unknown';
                    confidenceLevels[confidence] = (confidenceLevels[confidence] || 0) + 1;
                    
                    // Column sources
                    const column = result.matched_in_column || 'unknown';
                    columnSources[column] = (columnSources[column] || 0) + 1;
                    
                    // State distribution
                    const state = result.state_name || 'Unknown';
                    stateDistribution[state] = (stateDistribution[state] || 0) + 1;
                }
            });

            let html = `
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-number">${totalMatches}</div>
                        <div class="stat-label">Total Matches</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${results.length - totalMatches}</div>
                        <div class="stat-label">No Matches</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${Object.keys(stateDistribution).length}</div>
                        <div class="stat-label">States Found</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-number">${Object.keys(columnSources).length}</div>
                        <div class="stat-label">Source Columns</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                    <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 10px;">
                        <h4>üìä Match Types</h4>
                        ${Object.entries(matchTypes).map(([type, count]) => 
                            `<div style="display: flex; justify-content: space-between; margin: 5px 0;">
                                <span>${type}</span>
                                <strong>${count}</strong>
                            </div>`
                        ).join('')}
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 10px;">
                        <h4>üéØ Confidence Levels</h4>
                        ${Object.entries(confidenceLevels).map(([level, count]) => 
                            `<div style="display: flex; justify-content: space-between; margin: 5px 0;">
                                <span>${level}</span>
                                <strong>${count}</strong>
                            </div>`
                        ).join('')}
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                    <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 10px;">
                        <h4>üìù Source Columns</h4>
                        <div style="max-height: 200px; overflow-y: auto;">
                            ${Object.entries(columnSources)
                                .sort(([,a], [,b]) => b - a)
                                .map(([column, count]) => 
                                    `<div style="display: flex; justify-content: space-between; margin: 5px 0; font-size: 13px;">
                                        <span>${column}</span>
                                        <strong>${count}</strong>
                                    </div>`
                                ).join('')}
                        </div>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.8); padding: 20px; border-radius: 10px;">
                        <h4>üó∫Ô∏è Top States Found</h4>
                        <div style="max-height: 200px; overflow-y: auto;">
                            ${Object.entries(stateDistribution)
                                .sort(([,a], [,b]) => b - a)
                                .slice(0, 15)
                                .map(([state, count]) => 
                                    `<div style="display: flex; justify-content: space-between; margin: 5px 0; font-size: 13px;">
                                        <span>${state}</span>
                                        <strong>${count}</strong>
                                    </div>`
                                ).join('')}
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Add active class to selected tab
            event.target.classList.add('active');
        }

        function updateMatch(index, cityData) {
            if (!cityData || !processedData) return;
            
            try {
                const newCity = JSON.parse(cityData);
                const record = processedData[index];
                
                // Update all city-related fields
                Object.keys(newCity).forEach(key => {
                    record[key] = newCity[key];
                });
                
                record.match_confidence = 'manual_edit';
                record.match_type = 'manual_override';
                
                // Refresh the display
                displayEditInterface(processedData);
                
                console.log(`Updated record ${index} with new city:`, newCity.city, newCity.state_name);
            } catch (e) {
                console.error('Error updating match:', e);
            }
        }

        function removeMatch(index) {
            if (!processedData) return;
            
            const record = processedData[index];
            
            // Clear all location-related fields
            Object.keys(citiesData[0] || {}).forEach(key => {
                record[key] = '';
            });
            
            record.location_match = 'NO';
            record.match_confidence = 'removed';
            record.match_type = 'manual_removal';
            record.matched_in_column = '';
            record.matched_text_fragment = '';
            
            // Refresh displays
            displayEditInterface(processedData);
            const totalMatches = processedData.filter(r => r.location_match === 'YES').length;
            displayAllResults(processedData, totalMatches);
            
            console.log(`Removed match for record ${index}`);
        }

        function downloadResults() {
            if (!processedData || processedData.length === 0) {
                alert('No data to download. Please process the data first.');
                return;
            }

            const csv = Papa.unparse(processedData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `enhanced_location_data_${new Date().toISOString().split('T')[0]}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }

        // Make functions globally accessible
        window.switchTab = switchTab;
        window.updateMatch = updateMatch;
        window.removeMatch = removeMatch;