<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced CSV Location Data Merger</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .upload-box {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            transition: all 0.3s ease;
        }
        
        .upload-box:hover {
            border-color: #764ba2;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
            transform: translateY(-2px);
        }
        
        .upload-box h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .file-input {
            margin: 10px 0;
            padding: 10px 20px;
            border: none;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .file-input:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .settings-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.05), rgba(118, 75, 162, 0.05));
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }
        
        .settings-section h3 {
            margin-bottom: 15px;
            color: #333;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
        }
        
        .checkbox-item input[type="checkbox"] {
            margin-right: 8px;
            transform: scale(1.2);
        }
        
        .merge-btn {
            display: block;
            margin: 30px auto;
            padding: 15px 40px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 30px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        
        .merge-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 25px rgba(0,0,0,0.2);
        }
        
        .merge-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .results {
            margin-top: 30px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-radius: 12px;
            border-left: 5px solid #667eea;
        }
        
        .results h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .download-btn {
            padding: 10px 25px;
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            margin: 10px 5px;
            transition: all 0.3s ease;
        }
        
        .download-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .status {
            padding: 15px;
            margin: 15px 0;
            border-radius: 8px;
            font-weight: bold;
        }
        
        .status.success {
            background: rgba(40, 167, 69, 0.1);
            color: #155724;
            border: 1px solid rgba(40, 167, 69, 0.2);
        }
        
        .status.error {
            background: rgba(220, 53, 69, 0.1);
            color: #721c24;
            border: 1px solid rgba(220, 53, 69, 0.2);
        }
        
        .status.info {
            background: rgba(23, 162, 184, 0.1);
            color: #0c5460;
            border: 1px solid rgba(23, 162, 184, 0.2);
        }
        
        .status.warning {
            background: rgba(255, 193, 7, 0.1);
            color: #856404;
            border: 1px solid rgba(255, 193, 7, 0.2);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
            font-size: 14px;
        }
        
        th {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            font-weight: bold;
        }
        
        tr:hover {
            background: rgba(102, 126, 234, 0.05);
        }
        
        .preview-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            margin-top: 15px;
        }
        
        .confidence-high { background-color: rgba(40, 167, 69, 0.1); }
        .confidence-medium { background-color: rgba(255, 193, 7, 0.1); }
        .confidence-low { background-color: rgba(220, 53, 69, 0.1); }
        
        .verification-panel {
            background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(40, 167, 69, 0.2));
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #28a745;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .stat-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
        }
        
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ Enhanced CSV Location Data Merger</h1>
        <p style="text-align: center; color: #666; margin-bottom: 30px;">Verified location matching with enhanced accuracy and validation</p>
        
        <div class="upload-section">
            <div class="upload-box">
                <h3>üìç Cities CSV File</h3>
                <p>Upload your cities data with location information</p>
                <input type="file" id="citiesFile" accept=".csv" class="file-input">
                <div id="citiesStatus"></div>
            </div>
            
            <div class="upload-box">
                <h3>üë• Bio Data CSV File</h3>
                <p>Upload your bio/influencer data</p>
                <input type="file" id="bioFile" accept=".csv" class="file-input">
                <div id="bioStatus"></div>
            </div>
        </div>
        
        <div class="settings-section">
            <h3>üîß Matching Settings & Verification</h3>
            <div class="checkbox-group">
                <div class="checkbox-item">
                    <input type="checkbox" id="strictMode" checked>
                    <label for="strictMode">Strict matching mode (higher accuracy)</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="requireStateMatch" checked>
                    <label for="requireStateMatch">Require state verification</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="validateAbbreviations" checked>
                    <label for="validateAbbreviations">Validate state abbreviations</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="contextualMatching" checked>
                    <label for="contextualMatching">Use contextual keywords</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="crossValidation">
                    <label for="crossValidation">Cross-validate matches</label>
                </div>
                <div class="checkbox-item">
                    <input type="checkbox" id="excludePartialWords">
                    <label for="excludePartialWords">Exclude partial word matches</label>
                </div>
            </div>
        </div>
        
        <button id="mergeBtn" class="merge-btn" disabled>üîÑ Merge Data with Verification</button>
        
        <div id="results" class="results" style="display: none;">
            <h3>üìä Enhanced Merge Results</h3>
            <div id="mergeStatus"></div>
            <div id="previewContainer"></div>
        </div>
    </div>

    <script>
        let citiesData = null;
        let bioData = null;
        let mergedData = null;
        let cityIndex = new Map();
        let stateIndex = new Map();
        let abbreviationMap = new Map();

        // Enhanced US State data with common variations
        const US_STATES = {
            'AL': 'Alabama', 'AK': 'Alaska', 'AZ': 'Arizona', 'AR': 'Arkansas', 'CA': 'California', 'CO': 'Colorado',
            'CT': 'Connecticut', 'DE': 'Delaware', 'FL': 'Florida', 'GA': 'Georgia', 'HI': 'Hawaii', 'ID': 'Idaho',
            'IL': 'Illinois', 'IN': 'Indiana', 'IA': 'Iowa', 'KS': 'Kansas', 'KY': 'Kentucky', 'LA': 'Louisiana',
            'ME': 'Maine', 'MD': 'Maryland', 'MA': 'Massachusetts', 'MI': 'Michigan', 'MN': 'Minnesota', 'MS': 'Mississippi',
            'MO': 'Missouri', 'MT': 'Montana', 'NE': 'Nebraska', 'NV': 'Nevada', 'NH': 'New Hampshire', 'NJ': 'New Jersey',
            'NM': 'New Mexico', 'NY': 'New York', 'NC': 'North Carolina', 'ND': 'North Dakota', 'OH': 'Ohio', 'OK': 'Oklahoma',
            'OR': 'Oregon', 'PA': 'Pennsylvania', 'RI': 'Rhode Island', 'SC': 'South Carolina', 'SD': 'South Dakota',
            'TN': 'Tennessee', 'TX': 'Texas', 'UT': 'Utah', 'VT': 'Vermont', 'VA': 'Virginia', 'WA': 'Washington',
            'WV': 'West Virginia', 'WI': 'Wisconsin', 'WY': 'Wyoming'
        };

        // Location context keywords
        const LOCATION_CONTEXTS = [
            'from', 'in', 'at', 'based', 'located', 'live', 'lives', 'resident', 'living',
            'born', 'raised', 'grew up', 'hometown', 'home', 'city', 'state', 'area',
            'üìç', 'üìå', 'üó∫Ô∏è', 'üèôÔ∏è', 'üè†', 'üåÜ', '‚ö°', '‚úàÔ∏è'
        ];

        // Word boundaries and separators
        const WORD_SEPARATORS = /[\s,;.:!?\-_\(\)\[\]{}|\/\\'"]+/;

        document.getElementById('citiesFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                parseCSV(file, 'cities');
            }
        });

        document.getElementById('bioFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                parseCSV(file, 'bio');
            }
        });

        document.getElementById('mergeBtn').addEventListener('click', mergeDataWithVerification);

        function parseCSV(file, type) {
            const statusDiv = document.getElementById(type + 'Status');
            statusDiv.innerHTML = '<div class="status info">üìÅ Parsing CSV...</div>';

            Papa.parse(file, {
                header: true,
                skipEmptyLines: true,
                dynamicTyping: true,
                complete: function(results) {
                    if (results.errors.length > 0) {
                        statusDiv.innerHTML = '<div class="status error">‚ùå Error parsing CSV: ' + results.errors[0].message + '</div>';
                        return;
                    }

                    if (type === 'cities') {
                        citiesData = results.data;
                        buildLocationIndexes(citiesData);
                        statusDiv.innerHTML = `<div class="status success">‚úÖ Cities data loaded: ${citiesData.length} records
                            <br>üèôÔ∏è Unique cities: ${cityIndex.size} | üó∫Ô∏è States: ${stateIndex.size}</div>`;
                    } else {
                        bioData = results.data;
                        statusDiv.innerHTML = '<div class="status success">‚úÖ Bio data loaded: ' + bioData.length + ' records</div>';
                    }

                    checkReadyToMerge();
                },
                error: function(error) {
                    statusDiv.innerHTML = '<div class="status error">‚ùå Error reading file: ' + error.message + '</div>';
                }
            });
        }

        function buildLocationIndexes(cities) {
            cityIndex.clear();
            stateIndex.clear();
            abbreviationMap.clear();

            cities.forEach(city => {
                if (!city) return;

                // Build city index
                if (city.city) {
                    const cityKey = normalizeText(city.city);
                    if (!cityIndex.has(cityKey)) {
                        cityIndex.set(cityKey, []);
                    }
                    cityIndex.get(cityKey).push(city);
                }

                if (city.city_ascii && city.city_ascii !== city.city) {
                    const cityAsciiKey = normalizeText(city.city_ascii);
                    if (!cityIndex.has(cityAsciiKey)) {
                        cityIndex.set(cityAsciiKey, []);
                    }
                    cityIndex.get(cityAsciiKey).push(city);
                }

                // Build state index
                if (city.state_name) {
                    const stateKey = normalizeText(city.state_name);
                    if (!stateIndex.has(stateKey)) {
                        stateIndex.set(stateKey, []);
                    }
                    stateIndex.get(stateKey).push(city);
                }

                if (city.state_id) {
                    const stateIdKey = normalizeText(city.state_id);
                    if (!stateIndex.has(stateIdKey)) {
                        stateIndex.set(stateIdKey, []);
                    }
                    stateIndex.get(stateIdKey).push(city);
                    
                    // Build abbreviation map
                    abbreviationMap.set(city.state_id.toUpperCase(), city.state_name);
                }
            });

            console.log(`Indexes built: ${cityIndex.size} cities, ${stateIndex.size} states`);
        }

        function normalizeText(text) {
            if (!text) return '';
            return text.toLowerCase().trim();
        }

        function checkReadyToMerge() {
            const mergeBtn = document.getElementById('mergeBtn');
            if (citiesData && bioData) {
                mergeBtn.disabled = false;
                mergeBtn.textContent = `üîÑ Merge Data (${citiesData.length} cities + ${bioData.length} bio records)`;
            }
        }

        function extractLocationWords(text, contextual = true) {
            if (!text || typeof text !== 'string') return [];
            
            const words = [];
            let normalizedText = text.toLowerCase();
            
            // If contextual matching is enabled, look for location context
            if (contextual && document.getElementById('contextualMatching').checked) {
                for (const context of LOCATION_CONTEXTS) {
                    const contextIndex = normalizedText.indexOf(context.toLowerCase());
                    if (contextIndex !== -1) {
                        // Extract words near the context (within 50 characters)
                        const start = Math.max(0, contextIndex - 25);
                        const end = Math.min(normalizedText.length, contextIndex + context.length + 25);
                        const contextArea = normalizedText.substring(start, end);
                        
                        const contextWords = contextArea.split(WORD_SEPARATORS)
                            .filter(word => word && word.length > 1)
                            .map(word => word.trim());
                        
                        words.push(...contextWords);
                    }
                }
            }
            
            // Also extract all words from the entire text
            const allWords = normalizedText.split(WORD_SEPARATORS)
                .filter(word => word && word.length > 1)
                .map(word => word.trim());
            
            words.push(...allWords);
            
            // Remove duplicates and filter out common non-location words
            const uniqueWords = [...new Set(words)];
            const filteredWords = uniqueWords.filter(word => !isCommonWord(word));
            
            return filteredWords;
        }

        function isCommonWord(word) {
            const commonWords = new Set([
                'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',
                'is', 'are', 'was', 'were', 'be', 'been', 'have', 'has', 'had', 'do', 'does', 'did',
                'will', 'would', 'could', 'should', 'may', 'might', 'can', 'must', 'shall',
                'i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
                'my', 'your', 'his', 'her', 'its', 'our', 'their', 'mine', 'yours', 'ours', 'theirs',
                'this', 'that', 'these', 'those', 'here', 'there', 'where', 'when', 'why', 'how',
                'what', 'which', 'who', 'whom', 'whose', 'all', 'any', 'some', 'many', 'much',
                'more', 'most', 'less', 'least', 'few', 'several', 'both', 'either', 'neither',
                'each', 'every', 'other', 'another', 'such', 'same', 'different', 'new', 'old',
                'good', 'bad', 'great', 'small', 'big', 'large', 'long', 'short', 'high', 'low'
            ]);
            
            return commonWords.has(word.toLowerCase()) || word.length < 2;
        }

        function validateStateAbbreviation(abbr) {
            if (!abbr || typeof abbr !== 'string') return null;
            const upperAbbr = abbr.toUpperCase();
            return US_STATES[upperAbbr] || null;
        }

        function findBestLocationMatch(text, requireState = true) {
            if (!text || typeof text !== 'string') return null;
            
            const words = extractLocationWords(text, true);
            let bestMatch = null;
            let highestScore = 0;
            
            // First, try to find exact city matches
            for (const word of words) {
                const normalizedWord = normalizeText(word);
                
                if (cityIndex.has(normalizedWord)) {
                    const cities = cityIndex.get(normalizedWord);
                    
                    for (const city of cities) {
                        let score = calculateMatchScore(city, word, 'city');
                        
                        // Bonus for state validation if required
                        if (requireState && document.getElementById('requireStateMatch').checked) {
                            const stateValidated = validateStateInText(text, city);
                            if (stateValidated) {
                                score += 50;
                            } else {
                                score = Math.max(0, score - 25); // Reduce score if state doesn't match
                            }
                        }
                        
                        if (score > highestScore) {
                            highestScore = score;
                            bestMatch = {
                                city: city,
                                matchType: 'city_exact',
                                matchedWord: word,
                                confidence: score > 80 ? 'high' : score > 50 ? 'medium' : 'low',
                                score: score,
                                verification: {
                                    wordBoundary: checkWordBoundary(text, word),
                                    contextRelevant: checkLocationContext(text, word),
                                    stateConsistent: requireState ? validateStateInText(text, city) : true
                                }
                            };
                        }
                    }
                }
            }
            
            // If no city match and not in strict mode, try state matches
            if (!bestMatch && !document.getElementById('strictMode').checked) {
                for (const word of words) {
                    const normalizedWord = normalizeText(word);
                    
                    if (stateIndex.has(normalizedWord)) {
                        const cities = stateIndex.get(normalizedWord);
                        // Get the largest city for the state
                        const largestCity = cities.reduce((largest, current) => 
                            (current.population || 0) > (largest.population || 0) ? current : largest
                        );
                        
                        const score = calculateMatchScore(largestCity, word, 'state');
                        
                        if (score > highestScore) {
                            highestScore = score;
                            bestMatch = {
                                city: largestCity,
                                matchType: 'state_match',
                                matchedWord: word,
                                confidence: 'medium',
                                score: score,
                                verification: {
                                    wordBoundary: checkWordBoundary(text, word),
                                    contextRelevant: checkLocationContext(text, word),
                                    stateConsistent: true
                                }
                            };
                        }
                    }
                    
                    // Check state abbreviations
                    if (document.getElementById('validateAbbreviations').checked) {
                        const stateFullName = validateStateAbbreviation(word);
                        if (stateFullName) {
                            const stateKey = normalizeText(stateFullName);
                            if (stateIndex.has(stateKey)) {
                                const cities = stateIndex.get(stateKey);
                                const largestCity = cities.reduce((largest, current) => 
                                    (current.population || 0) > (largest.population || 0) ? current : largest
                                );
                                
                                const score = calculateMatchScore(largestCity, word, 'abbreviation') + 25;
                                
                                if (score > highestScore) {
                                    highestScore = score;
                                    bestMatch = {
                                        city: largestCity,
                                        matchType: 'state_abbreviation',
                                        matchedWord: word,
                                        confidence: 'high',
                                        score: score,
                                        verification: {
                                            wordBoundary: checkWordBoundary(text, word),
                                            contextRelevant: checkLocationContext(text, word),
                                            stateConsistent: true
                                        }
                                    };
                                }
                            }
                        }
                    }
                }
            }
            
            // Final validation checks
            if (bestMatch && document.getElementById('crossValidation').checked) {
                if (!performCrossValidation(bestMatch, text)) {
                    return null;
                }
            }
            
            return bestMatch;
        }

        function calculateMatchScore(city, matchedWord, matchType) {
            let score = 0;
            
            // Base score by match type
            switch (matchType) {
                case 'city': score = 100; break;
                case 'state': score = 60; break;
                case 'abbreviation': score = 80; break;
                default: score = 50;
            }
            
            // Population bonus (larger cities get higher scores)
            const population = city.population || 0;
            if (population > 1000000) score += 30;
            else if (population > 100000) score += 20;
            else if (population > 10000) score += 10;
            
            // Length bonus (longer matches are generally more reliable)
            score += Math.min(matchedWord.length * 2, 20);
            
            return score;
        }

        function validateStateInText(text, city) {
            if (!city.state_name && !city.state_id) return false;
            
            const normalizedText = normalizeText(text);
            const stateName = normalizeText(city.state_name || '');
            const stateId = normalizeText(city.state_id || '');
            
            return normalizedText.includes(stateName) || 
                   normalizedText.includes(stateId) ||
                   (city.state_id && normalizedText.includes(city.state_id.toLowerCase()));
        }

        function checkWordBoundary(text, word) {
            if (document.getElementById('excludePartialWords').checked) {
                const regex = new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
                return regex.test(text);
            }
            return true;
        }

        function checkLocationContext(text, word) {
            const normalizedText = normalizeText(text);
            const wordIndex = normalizedText.indexOf(normalizeText(word));
            
            if (wordIndex === -1) return false;
            
            // Check 30 characters before and after the word
            const start = Math.max(0, wordIndex - 30);
            const end = Math.min(normalizedText.length, wordIndex + word.length + 30);
            const context = normalizedText.substring(start, end);
            
            return LOCATION_CONTEXTS.some(ctx => context.includes(normalizeText(ctx)));
        }

        function performCrossValidation(match, originalText) {
            // Additional validation logic
            const { city, matchedWord, verification } = match;
            
            // Must have proper word boundaries if enabled
            if (!verification.wordBoun